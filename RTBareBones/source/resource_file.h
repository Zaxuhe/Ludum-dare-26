#ifndef RESOURCEFILE_H
#define RESOURCEFILE_H

#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#ifdef _WIN32
    #include <io.h>
    #include <process.h> /* for getpid() and the exec..() family */
    #include <stdlib.h>
#else
    #include <unistd.h>
#endif
#include <string>
#include <iostream>
#include <map>
#include "BaseApp.h"
#include "Entity/EntityUtils.h"
#include "Entity/TouchHandlerComponent_Zax.h"

#include "boost/function.hpp"

struct tile_data
{
	/**
	* Constructor
	**/
	tile_data(float _x, float _y, int _time =-1)
	{
		x_ = _x;
		y_ = _y;
		time_ = _time;
	};

	//the time the frame will last, in miliseconds
	int time_;
	float x_;
	float y_;

};

/**
* This represent an animation, the name of the file is represented as the key on the map
*/
class frames
{
public:

	/**
	* The amount of frames that this animation will loop in a second
	*/
    float frames_per_second_;

	/**
	* The name of the original file
	*/
	std::string final_name_;

	/**
	* The total number of frames the animation has
	*/
	int total_frames_;

	/**
	* The size of each frame
	*/
	int frame_width_;
	int frame_height_;

	/**
	* if the frame was started empty, it is not started, if the frame contains data, its started
	*/
	bool started_;

	/**
	* the frame was loaded
	*/
	bool loaded_;

	/**
	* a list with each frame data, the data is position and time
	*/
	std::vector<tile_data> tiles_data;

	/**
	* 
	*/
	frames()
	{
		started_ = false;
		loaded_ = false;
		frame_width_ = -100;
		frame_height_ = -100;
		final_name_ =""; 
		frames_per_second_ = 1;
		total_frames_ = 1;

	}

	frames(int _frame_width, int _frame_height, std::string _final_name = "", float _frames_per_second = 3)
	{
		started_ = true;
		loaded_ = false;
		final_name_ = _final_name;
		frame_width_ = _frame_width;
		frame_height_ = _frame_height;
		frames_per_second_ = _frames_per_second;
		//we mark it as not initialized
	}

	/**
	* This function will set the time on each frame if it was not set before
	*/
	void init_frames()
	{
		for (int i = 0; i < tiles_data.size(); i++)
		{
			if (tiles_data[i].time_ == -1)
			{
				tiles_data[i].time_ = 1000.0f / frames_per_second_;
			}
		}
	}
};

class texture_anim
{
public:

	void set_frame(frames *_setter)
	{
		//revisamos que el setter este activado y que el sprite este activado
		if (_setter->started_ && _setter->loaded_ == false)
		{

			/*for (int i=0; i<_setter->tiles_data.size(); i++)
			{
				_setter->tiles_data[i].x_ = _setter->tiles_data[i].x_;
				_setter->tiles_data[i].y_ = _setter->tiles_data[i].y_;
			}*/

			_setter->total_frames_ = _setter->tiles_data.size();
			_setter->init_frames();
			_setter->loaded_ = true;
			
		}
		else if (_setter->started_ == false)
		{
			_setter->total_frames_ = 1;
			_setter->frame_width_ = animation->GetWidth();
			_setter->frame_height_ = animation->GetHeight();
			_setter->tiles_data.clear();
			_setter->tiles_data.push_back(tile_data(0,0,1000));
		}

		frame = _setter;
		
	}

	SurfaceAnim* animation;
	frames* frame;

	bool started;

	texture_anim()
	{
		started = false;
	}

	void setup_anim(int frames_x, int frames_y, int start_y__ = 0, int total_frames_ = 1)
	{
		animation->SetupAnim(1,1);
	}
};

/**
* This contains all the images, get_image will return the texture_anim
*/
class resource_file
{
public:
    /**
    * Constructor, sets the default resource file name
    */
    resource_file();

    /**
    * Destructor
    */
    virtual ~resource_file();

    /**
    * Gets an image, loads it and return the texture id
	* We can use this to preload an image
    * @param _name add the image with that name, like test.png
    */
    texture_anim* get_image(std::string _name);


	/**
	* We load the sets of animations generated by the maxscript script
	*/
	void animations_load();

	int count_images_;

	//base app has already been freed? we are freeing all the memory then
	bool base_app_deleted_;

private:

    /**
    * a map containing all the textures already loaded
    */
    std::map <std::string, texture_anim*> images_loaded_;

	/**
	* a map contaning all frames information
	*/
	std::map <std::string, frames> frames_data_;
};

extern resource_file g_resources;

/**
* This is where all the images are stored
*
* Usage: image_object image_ship("image.rttex");
*
*/
class image_object_
{
public:

	image_object_(std::string _filename = "test.bmp", bool _draw_itself = true);

	virtual ~image_object_()
	{
		if (g_resources.base_app_deleted_ == false)
		{
			GetMessageManager()->DeleteMessagesToEntity(entity_);
			entity_->GetParent()->RemoveEntityByAddress(entity_);
		}

	}

	/**
	* Parameters
	* Posible callback names
	* "OnTouchStart"
	* "OnTouchEnd"
	* "OnOverStart"
	* "OnOverEnd"
	* "OnOverMove"
	*
	* functor, a bind to the new function
	* option 1: boost::bind(&image_object_::on_entity_touched, this, _1)
	* option 2: a normal c function &function_name
	*/
	void set_click_function(std::string callback_name, boost::function<void(VariantList *pVList)> functor)
	{
		//We add input if needed and made atleast one cicle
		if (has_input_ == false)
		{
			FocusInputComponent *pComp = (FocusInputComponent*)entity_->AddComponent(new FocusInputComponent);
			pComp->GetFunction("LinkMoveMessages")->sig_function(NULL);

 			EntityComponent *pComp2 = entity_->AddComponent(new TouchHandlerComponent_Zax);

			//quitamos el touch padding
			entity_->GetVar("touchPadding")->Set(CL_Rectf(0.0f, 0.0f, 0.0f, 0.0f));

			has_input_ = true;
		}

		entity_->GetFunction(callback_name)->sig_function.connect(functor);
	}

	//just for tests
	/*void on_entity_touched(VariantList *pVList)
	{
		set_position(get_x()+20,get_y()+20);
	}*/

	/**
	* if the object position has been changed
	*/
	void on_position_changed(Variant *pDataObject)
	{
		pos2d_ = entity_->GetVar("pos2d")->GetVector2();
	}

	float get_x()
	{
		return pos2d_.x;
	}

	float get_y()
	{
		return pos2d_.y;
	}

	float get_rotation()
	{
		return rotation_;
	}

	bool get_enabled()
	{
		return enabled_;
	}

	std::string get_filename()
	{
		return filename_;
	}

	bool get_animation_loop()
	{
		return animation_loops_;
	}

	/**
	* We change the position
	* 
	* @param _x, the new _x
	* @param _y, the new _y
	* @param _in_ms if you want to change it after the ms has passed
	*/
	void set_position(float _x, float _y, int _in_ms = 0)
	{
		//we do it now
		if (_in_ms == 0)
		{
			entity_->GetVar("pos2d")->Set(CL_Vec2f(_x,_y));
		}
		else //we do it later
		{
			GetMessageManager()->SetEntityVariable(entity_, _in_ms, "pos2d", CL_Vec2f(_x,_y));
		}
	}

	/**
	* if the object animatio loop has been changed
	*/
	void on_animation_loop_changed(Variant *pDataObject)
	{
		animation_loops_ = entity_->GetVar("animation_loop")->GetUINT32();
	}

	/**
	* if the object enabled has been changed
	*/
	void on_enabled_changed(Variant *pDataObject)
	{
		enabled_ = entity_->GetVar("enabled")->GetUINT32();
	}

	/**
	* if the object rotation has been changed
	*/
	void on_rotation_changed(Variant *pDataObject)
	{
		rotation_ = entity_->GetVar("rotation")->GetFloat();
	}

	/**
	* if the object transparency has been changed
	*/
	void on_transparency_changed(Variant *pDataObject)
	{
		transparency_ = entity_->GetVar("transparency")->GetFloat();
	}

	/**
	* if the object filename has been changed
	*/
	void on_filename_changed(Variant *pDataObject);

	/**
	* We change an image
	* 
	* @param _new_name, change the image to another filename
	* @param _in_ms if you want to change it after the ms has passed
	*/
	void set_filename(std::string new_name, int _in_ms = 0)
	{
		//we do it now
		if (_in_ms == 0)
		{
			entity_->GetVar("filename")->Set(new_name);
		}
		else
		{
			GetMessageManager()->SetEntityVariable(entity_, _in_ms, "filename", new_name);
		}
		
	}

	/**
	* We use the center as the center of all the image
	* 
	* @param _usar
	*/
	void usar_centro(bool _usar = true)
	{
		centro_ = _usar;
	}

	/**
	* We rotate the image
	* 
	* @param _rotation, angle to rotate the image
	* @param _in_ms if you want to change it after the ms has passed
	*/
	void set_rotation(float _rotation, int _in_ms = 0)
	{
		//we do it now
		if (_in_ms == 0)
		{
			entity_->GetVar("rotation")->Set(_rotation);
		}
		else
		{
			GetMessageManager()->SetEntityVariable(entity_, _in_ms, "rotation", _rotation);
		}
	}

	/**
	* We set the transparency
	* 
	* @param _transparency, new transparency
	* @param _in_ms if you want to change it after the ms has passed
	*/
	void set_transparency(float _transparency, int _in_ms = 0)
	{
		//we do it now
		if (_in_ms == 0)
		{
			entity_->GetVar("transparency")->Set(_transparency);
		}
		else
		{
			GetMessageManager()->SetEntityVariable(entity_, _in_ms, "transparency", _transparency);
		}
	}

	/**
	* We rotate the image in x time interpolating
	* 
	* @param _rotation, angle to rotate the image
	* @param _interpolation_time duration to get to the target rotation
	* @param _in_ms if you want to start after x time has passed
	* NOTA: parece que en estado actual de proton, no funcion _in_ms
	*/
	void set_rotation_interpolate(float _rotation, int _interpolation_time, int _in_ms = 0)
	{
		//GetMessageManager()->SetEntityVariable(entity_, _in_ms, "rotation", _rotation);
		MorphToFloatEntity(entity_, "rotation", _rotation, _interpolation_time,INTERPOLATE_LINEAR,_in_ms);
	}

	/**
	* We set the transparency of the image in x time interpolating
	* 
	* @param _transparency, transparency to change the image
	* @param _interpolation_time duration to get to the target rotation
	* @param _in_ms if you want to start after x time has passed
	* NOTA: parece que en estado actual de proton, no funcion _in_ms
	*/
	void set_transparency_interpolate(float _transparency, int _interpolation_time, int _in_ms = 0)
	{
		//GetMessageManager()->SetEntityVariable(entity_, _in_ms, "rotation", _rotation);
		MorphToFloatEntity(entity_, "transparency", _transparency, _interpolation_time,INTERPOLATE_LINEAR,_in_ms);
	}


	/**
	* We disable/enable the loop
	* 
	* @param _loop, true if enabled, false if disabled
	* @param _in_ms if you want to change it after the ms has passed
	*/
	void set_animation_loop(bool _loop, int _in_ms = 0)
	{
		if (_in_ms == 0)
		{
			
			if (_loop)
			{
				entity_->GetVar("animation_loop")->Set(uint32(1));
			}
			else
			{
				entity_->GetVar("animation_loop")->Set(uint32(0));
			}
		}
		else
		{
			if (_loop)
			{
				GetMessageManager()->SetEntityVariable(entity_, _in_ms, "animation_loop", uint32(1));
			}
			else
			{
				GetMessageManager()->SetEntityVariable(entity_, _in_ms, "animation_loop", uint32(0));
			}
		}
	}

	/**
	* We position the image in x time interpolating
	* 
	* @param _x, postion the image will reach
	* @param _y, position the image will reach
	* @param _interpolation_time duration to get to the target rotation
	* @param _in_ms if you want to start after x time has passed
	* NOTA: parece que en estado actual de proton, no funcion _in_ms
	*/
	void set_position_interpolate(float _x, float _y, int _interpolation_time, int _in_ms = 0)
	{
		//GetMessageManager()->SetEntityVariable(entity_, _in_ms, "rotation", _rotation);
		MorphToVec2Entity(entity_, "pos2d", CL_Vec2f(_x,_y), _interpolation_time,INTERPOLATE_LINEAR,_in_ms);
	}

	/**
	* We disable/enable the image
	* 
	* @param _enabled, true if enabled, false if disabled
	* @param _in_ms if you want to change it after the ms has passed
	*/
	void set_enabled(bool _enabled, int _in_ms = 0)
	{
		if (_in_ms == 0)
		{
			
			if (_enabled)
			{
				entity_->GetVar("enabled")->Set(uint32(1));
			}
			else
			{
				entity_->GetVar("enabled")->Set(uint32(0));
			}
		}
		else
		{
			if (_enabled)
			{
				GetMessageManager()->SetEntityVariable(entity_, _in_ms, "enabled", uint32(1));
			}
			else
			{
				GetMessageManager()->SetEntityVariable(entity_, _in_ms, "enabled", uint32(0));
			}
		}
	}

	/**
	* We change a frame
	* 
	* @param _frame_num, we change to another frame
	* @param _in_ms, how much time until we change the frame
	*/
	void next_frame(VariantList *pVList)
	{
		GetMessageManager()->DeleteMessagesByFunctionCallName(object_name_);
		
		//the animation will loop if not finished
		if (animation_finished_ == false)
		{
			current_frame_++;
		}

		if (current_frame_ >= anim_data_->frame->total_frames_)
		{
			current_frame_ = 0;
			if (animation_loops_ == false) //the animation does not loops, so we end it
			{
				animation_finished_ = true;
			}
		}

		tex_x_ = anim_data_->frame->tiles_data[current_frame_].x_;
		tex_y_ = anim_data_->frame->tiles_data[current_frame_].y_;



		//we could move this to the image load
		frame_width_ = anim_data_->frame->frame_width_;
		frame_height_ = anim_data_->frame->frame_height_;

		entity_->GetVar("size2d")->Set(anim_data_->frame->frame_width_, anim_data_->frame->frame_height_);
		VariantList t_2(entity_);
		if (anim_data_->frame->total_frames_ != 1)
		{
			//LogMsg("Aqui estoy");
			GetMessageManager()->CallEntityFunction(entity_, anim_data_->frame->tiles_data[current_frame_].time_, object_name_, &t_2);
		}
	}

	/**
	* We draw the object
	*/
	void draw(VariantList *pVList = 0)
	{
		if (!enabled_)
		{
			return;
		}
		
		if (centro_)
		{
			
			anim_data_->animation->BlitScaledAnimZax(pos2d_.x,pos2d_.y,tex_x_,tex_y_,frame_width_,frame_height_,CL_Vec2f(1,1),ALIGNMENT_CENTER,MAKE_RGBA(255,255,255,transparency_),rotation_,CL_Vec2f(pos2d_.x,pos2d_.y));
		}
		else
		{
		
			anim_data_->animation->BlitScaledAnimZax(pos2d_.x,pos2d_.y,tex_x_,tex_y_,frame_width_,frame_height_,CL_Vec2f(1,1),ALIGNMENT_UPPER_LEFT,MAKE_RGBA(255,255,255,transparency_),rotation_,CL_Vec2f((float)anim_data_->frame->frame_width_/2.0f+pos2d_.x,(float)anim_data_->frame->frame_height_/2.0f+pos2d_.y));
		}
	}
	bool animation_finished_;//the animation has looped atleast once?
	bool animation_loops_;
	int frame_width_;
	int frame_height_;
	texture_anim* anim_data_;
	bool enabled_;

	private:

	float transparency_;
	float rotation_;
	std::string filename_;
	CL_Vec2f pos2d_;
	//the entity of the object
	Entity* entity_;
	int current_frame_;
	int tex_x_;
	int tex_y_;
	

	bool has_input_;

	bool draw_itself_;// if set to true we will draw it self, if its false you have to call draw manually

	bool centro_;

	std::string object_name_; //the name is unique
};
#endif // RESOURCEFILE_H
